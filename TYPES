Types
-----

Here are some thoughts about types.

Variables can only hold a single type during their lifetime, basically to make
inference easier. This isn't generally a huge cost to the developer. What
stops that type being ANY though? Being used in a way that needs something more
specific. (Assigned but never used variables may be ANY.)

Basic inference.
----------------

Types don't have to be specified for a variable, they are inferred from the
way a variable is used.

Perhaps they can be specified if the developer wishes.

When a variable is used in an expression, then types are inferred from how
it is used.

  a = 1

infers that a is an int.

There will be a hierarchy of types. A type inference can be expanded as
needed up a hierarchy. e.g.

  a = 1
  a = 1.0

will change the inference when it sees the second declaration.


There are two contributors to constraints:

  1. Use: when a variable is used then its type is constrained by the
     way that it is used. Passing it to a function means that it must
     be a subtype of the relevant argument type. This restricts the
     types that the variable can hold.

  2. Definition: when a variable is defined, or updated, then it
     changes the type that the variable may hold. This causes an
     expansion in the possible types.

We need to find a type scheme that satisfies all of these constraints
at the same time.


Type checking
-------------

Consider

def f(a:int):
   return a.tofloat()

If we aren't going to require declarations everwhere, then what do we do
when this is called with something we can't guarantee to be an int? We
can be like Python and let it through, and allow duck-typing to work.

We could also inject runtime type checks on this function.

Would it be possible to omit the type checks if we could guarantee that
the function was never called with anything other than an int? What about
public modules? The code could be called with anything.

Is there much point in allowing the duck typing? If you try and call without
an int and the type checker notices it will complain. Maybe a way to force
past the type check is needed?

Type classes
------------

Type classes/traits are great. It would be really nice to be able
to use them.

type Foo:
   trait File:
      def readline():
          ...

The type checker has to check that you implement all of the trait in your
block.

You can then call the method from a particular trait with

   f.File:readline()

and

   f.readline()

might work fine as long as there were no conflicts (run time error?).
The full name could be inferred from surrounding type declarations, so

  def foo(a: File):
      a.readline()

could be rewritten to a.File:readline() internally.

Case on types
-------------

I'd really like to copy Maybe, Either etc. from Haskell, and use that
for error handling as much as possible. I'm not sure what the syntax
is though, but it probably involves "case".

   def getline(f):
      line = f.File:readline()
      case line:
          Error e:
              sys.stderr.write(e)
              return Maybe.None()
          Ok line:
              print(line)
              return Maybe.Just(line)

getline is then (File => f) -> Maybe str
File:readline would be something like (File => f) --> MaybeError str

The type checker could then enforce that you use the full expansion in the
case block, but may not be necessary with just type checking on
what is done with the value.

How do you define a type such as this?

Maybe = new Enum<A>(None, Just(A)):

    def is_none(self):
        case self:
            None:
                return True
            Just a:
                return False


Type checking attribute access
------------------------------

When an attribute is accessed on something, we want to:

  1 generate a type variable for the type of the attribute
  2 check that the object has that attribute
  3 check that the type of the attribute matches the way that it is used

To do this:

  1 is quite easy.
  2 we can do with a constraint. (type(attr), SUBTYPE_OF, hasattr(type(obj), name))
    - Then when satisfying constraints we need to consider this new hasattr case.
  3 we can do this by replacing the hasattr constraint with one on the types.

There may be some post-processing needed if there are any hasattr() in the substitution?
